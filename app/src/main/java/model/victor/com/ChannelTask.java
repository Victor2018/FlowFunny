package model.victor.com;import android.content.Context;import android.os.AsyncTask;import android.os.Bundle;import android.text.TextUtils;import android.util.Log;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.Serializable;import java.net.SocketTimeoutException;import java.util.ArrayList;import java.util.List;import data.victor.com.Channel;import mode.victor.com.DataObservable;import util.victor.com.Constant;import util.victor.com.HttpUtil;public class ChannelTask {	private String TAG = "ChannelTask";	private int requestCount;	private Context mContext;	public ChannelTask(Context context) {		mContext = context;	}	public void requestChannelData() {		requestCount++;		Log.e(TAG, "requestCount=" + requestCount);		if(requestCount > 5){			return;		}		new ChannelInfoTask().execute(Constant.CHANNEL_URL);	}	class ChannelInfoTask extends AsyncTask<String, Integer, Bundle>{		@Override		protected Bundle doInBackground(String... params) {			// TODO Auto-generated method stub			int status = 0;			Bundle responseData = new Bundle();			if (HttpUtil.isNetEnable(mContext)){				String result = null;				try {					result = HttpUtil.HttpGetRequest(params[0]);					if (!TextUtils.isEmpty(result)) {						status = Constant.Msg.REQUEST_SUCCESS;						List<Channel> channels = parseChannels(result);						responseData.putSerializable(Constant.CHANNEL_DATA_KEY, (Serializable) channels);					} else {						status = Constant.Msg.REQUEST_FAILED;					}				} catch (SocketTimeoutException e) {					e.printStackTrace();					status = Constant.Msg.SOCKET_TIME_OUT;				}			} else {				status = Constant.Msg.NETWORK_ERROR;			}			responseData.putInt(Constant.STATUS_KEY, status);			responseData.putInt(Constant.REQUEST_MSG_KEY, Constant.Msg.CHANNEL_REQUEST);			return responseData;		}		protected void onPostExecute(Bundle result) {			if(result != null){				DataObservable.getInstance().setData(result);			}else{				requestChannelData();			}		}	}	private List<Channel> parseChannels (String datas) {		Log.e(TAG,"parseChannels()...");		List<Channel> channels = new ArrayList<>();		try{			JSONObject data = new JSONObject(datas);			JSONArray channelArry = data.getJSONArray("channels");			for (int i=0;i<channelArry.length();i++) {				JSONObject item = channelArry.getJSONObject(i);				Channel channel = new Channel();				channel.setName(item.getString("channel_name").trim());				channel.setEpg(item.getString("epg").trim());				JSONArray playUrlArry = item.getJSONArray("play_urls");				String[] playUrls = new String[playUrlArry.length()];				for (int j=0;j<playUrlArry.length();j++) {					playUrls[j] = playUrlArry.getJSONObject(j).getString("play_url");				}				channel.setPlayUrls(playUrls);				channels.add(channel);			}		}catch (JSONException e) {			e.printStackTrace();		}		return channels;	}}